# -*- coding: utf-8 -*-
"""
Created on Sat Oct 22 22:29:56 2022

@author: Thomas Tsangaris
"""

"""Purpose: Generate a plot of Ca-Ca inter-residue pairwise distance agreements  
versus the number of conformers in the second ensemble. This is meant for testing
statistical convergence of inter-residue Ca-Ca pairwise distances between the 
first ensemble using exact conformer weights and others that were generated by 
sampling the conformers with their associated weight with replacement.
 
"""
import MDAnalysis as md
import numpy as np
from MDAnalysis.analysis import distances
import matplotlib.pyplot as plt
import matplotlib as mpl
import glob
import csv
import itertools
import time
import scipy.stats as stat
from pylab import *

#My plotting preferences
font = {'family' : 'normal',
        'weight' : 'normal',
        'size'   : 20}

plt.rc('font', **font)

params = {'legend.fontsize': 10,
          'legend.handlelength': 1}
plt.rcParams.update(params)

ti=time.perf_counter()


# amino acid sequence
seq = "MSSSAGSGHQPSQSRAIPTRTVAISDAAQLPHDYCTTPGGTLFSTTPGGTRIIYDRKFLLDRRNSPMAQTPPCHLPNIPGVTSPGTLIEDSKVEVNNLNNLNNHDRKHAVGDDAQFEMDIC"


def get_weights(weights_file: str) -> list:
    """Return an array of weights, corresponding to each conformer in a pdb
    ensemble from a valid inputted path to a weights file (weights_file)
    where each row is a single floating point number, representing the weight
    of the conformer in the same order that the pdb ensemble is organized.
    
    Precondition: the weights file contains exactly one header line.
    
    """
    weights = []
    hl = 1
    
    with open(weights_file, 'r') as f:                                                                                          
        reader = csv.reader(f, delimiter='\t')
        for j in range(hl):
            # skip header
            next(reader)
        for row in reader:
            #Read remaining lines (row at a time)
            weights.append(float(row[0]))
        f.close()
    
    return weights


def compute_i_j_distance_map_stats(u_ens1: md.Universe, \
                              weights1: np.array) -> np.array:
    """Return the mean and std Ca-Ca pairwise distance matrices for the pdb ensemble
    represented by u_ens1 weighted by weights1.
    
    """
    N1 = len(u_ens1.residues) # number of residues in protein
    M1 = len(u_ens1.trajectory) # number of conformations in ensemble
    
    self_distances1 = np.zeros((M1, int((N1*(N1-1))/2)))
    std_self_distances1 = np.zeros((M1, int((N1*(N1-1))/2)))
    
    ind1=0
    for ts in u_ens1.trajectory: # iterate through all frames
        ca1=u_ens1.select_atoms('name CA')  # a selection (AtomGroup)
        self_distances1[ind1, :] = distances.self_distance_array(ca1.positions)
        ind1 += 1
    self_distances1_cp = np.copy(self_distances1) # copy for future calc

    # BME weighted average
    self_distances1=np.average(self_distances1, weights=weights1, axis=0)
    sq_dist_arr = np.zeros((N1, N1))
    triu = np.triu_indices_from(sq_dist_arr, k=1)
    sq_dist_arr[triu] = self_distances1
    sq_dist_arr.T[triu] = self_distances1
    
    # BME weighted std
    mean = np.average(self_distances1_cp, weights = weights1, axis=0)
    var_self_distances1 = np.average((self_distances1_cp - mean)**2, weights=weights1, axis=0)
    std_self_distances1 = np.sqrt(var_self_distances1)
    std_sq_dist_arr = np.zeros((N1, N1))
    std_triu = np.triu_indices_from(std_sq_dist_arr, k=1)
    std_sq_dist_arr[std_triu] = std_self_distances1
    std_sq_dist_arr.T[std_triu] = std_self_distances1
    
    Ca_ens1=sq_dist_arr
    std_Ca_ens1=std_sq_dist_arr

    return Ca_ens1, std_Ca_ens1 # mean first, std second


local = 10
N_to_disagree_counts = {}
N_to_disagree_counts_cutoff = {}
multi = 5 # how many runs of a single sampling do you have
mypath1 = "D:/testing_weight_conv/" # testing sampling convergence
weights_path1 = mypath1 + "test_50.dat" # testing sampling convergence
ensemble1 = glob.glob(mypath1 + "*.pdb") # list of pdb file paths
u_ens1 = md.Universe(ensemble1[0], ensemble1, in_memory=True)
# for equal weights:
numfiles1 = len(ensemble1) # for first ensemble, they may have different Nconf
equal_weights1 = []
for i in range(numfiles1):
    equal_weights1.append(1/numfiles1)
equal_weights1 = np.array(equal_weights1)
# extract weights from files
weights1 = get_weights(weights_path1)
# weights1 = equal_weights1

for k in [1, 2, 3, 5, 10, 15, 25, 35, 50, 60, 75, 85, 100, 125, 200, 400, 600]:
    for m in range(1, multi+1):
        
        # testing convergence
        mypath2 = mypath1 + str(k) + '_' + str(m) + '_conf/' # sampled with weights
        ensemble2 = glob.glob(mypath2 + "*.pdb") # list of pdb file paths
        u_ens2 = md.Universe(ensemble2[0], ensemble2, in_memory=True)
        
        numfiles2 = len(ensemble2) # for second ensemble, they may have different Nconf
        equal_weights2 = []
        for i in range(numfiles2):
            equal_weights2.append(1/numfiles2)
        equal_weights2 = np.array(equal_weights2)
        
        # weights2 = get_weights(weights_path2)
        weights2 = equal_weights2
        
        print("Sum of weights1:", sum(weights1))
        print("Sum of weights2:", sum(weights2))
        
        mean1, std1 = compute_i_j_distance_map_stats(u_ens1, weights1)
        mean2, std2 = compute_i_j_distance_map_stats(u_ens2, weights2)
        
        N1 = len(u_ens1.residues) # number of residues in protein
        sq_sig_arr = np.zeros((N1, N1))
        sq_sig_arr_cutoff = np.zeros((N1, N1)) # ignores residues within local angstroms of each other
        
        for i in range(N1):
            for j in range(N1):
                mean_1 = mean1[i][j]
                mean_2 = mean2[i][j]
                std_1 = std1[i][j]
                std_2 = std2[i][j]
                
                # check that difference of means is less than combined sdoms
                if abs(mean_1-mean_2) <= ((std_2/np.sqrt(numfiles1))+(std_2/np.sqrt(numfiles2))): # values agree
                    sq_sig_arr[i][j] = 0
                    sq_sig_arr_cutoff[i][j] = 0
                else : # values do not agree
                    sq_sig_arr[i][j] = 1
                    if abs(i-j) > local:
                        sq_sig_arr_cutoff[i][j] = 1
                        
        disagree_count = list((sq_sig_arr.flatten())).count(1)
        disagree_count_cutoff = list((sq_sig_arr_cutoff.flatten())).count(1)
        
        if k not in N_to_disagree_counts:
            N_to_disagree_counts[k] = []
        if k not in N_to_disagree_counts_cutoff:
            N_to_disagree_counts_cutoff[k] = []
            
        N_to_disagree_counts[k].append(disagree_count)
        N_to_disagree_counts_cutoff[k].append(disagree_count_cutoff)
      

# get values for plotting
N_lst = []
mean_disagree_count_lst = [] # each entry is a mean over 5 sampled runs
mean_disagree_count_lst_cutoff = []

for N in N_to_disagree_counts:
    N_lst.append(N)
    mean_disagree_count_lst.append(np.average(N_to_disagree_counts[N]))
    mean_disagree_count_lst_cutoff.append(np.average(N_to_disagree_counts_cutoff[N]))

# plot
plt.figure(figsize=(9,6)) # adjust figure size
plt.plot(N_lst, np.array(mean_disagree_count_lst)/2)
plt.xlabel("Sampled N", fontsize=16)
plt.ylabel("Average Number of Discrepant Distances", fontsize=16)
plt.ylim((0,1000))


plt.figure(figsize=(9,6)) # adjust figure size
plt.plot(N_lst, np.array(mean_disagree_count_lst_cutoff)/2)
plt.xlabel("Sampled N", fontsize=16)
plt.ylabel("Average Number of Non-local Discrepant Distances", fontsize=16)


# plot
plt.figure(figsize=(9,6)) # adjust figure size
plt.scatter(N_lst, np.array(mean_disagree_count_lst)/2)
plt.xlabel("Sampled N", fontsize=16)
plt.ylabel("Average Number of Discrepant Distances", fontsize=16)


plt.figure(figsize=(9,6)) # adjust figure size
plt.scatter(N_lst, np.array(mean_disagree_count_lst_cutoff)/2)
plt.xlabel("Sampled N", fontsize=16)
plt.ylabel("Average Number of Non-local Discrepant Distances", fontsize=16)


print(np.array(mean_disagree_count_lst)/2)
print(np.array(mean_disagree_count_lst_cutoff)/2)
    
tf=time.perf_counter()
total_time=tf-ti
print("Program took " + str(total_time) + " seconds")
